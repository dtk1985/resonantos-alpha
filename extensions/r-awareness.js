/**
 * R-Awareness V1.0 ‚Äî Silent SSoT Context Injector for OpenClaw
 * @version 1.0.0
 * @date 2026-02-15
 *
 * Keyword-triggered document injection into the system prompt.
 * Scans human AND AI messages for keywords, loads matching SSoT docs,
 * injects them into the system prompt so the AI treats them as existing knowledge.
 *
 * Hooks:
 *   before_agent_start  ‚Äî scan prompt, inject SSoT into systemPrompt
 *   agent_end            ‚Äî scan AI response, queue keywords for next turn
 *
 * Core principle: Silent success, visible errors.
 */

const fs = require("fs");
const path = require("path");

// ============================================================================
// Config
// ============================================================================
const DEFAULT_CONFIG = {
  enabled: true,
  ssotRoot: "",                     // REQUIRED: path to SSoT directory
  maxDocsPerTurn: 10,               // max documents injected per turn
  tokenBudget: 15000,               // max tokens of SSoT content per turn
  ttlTurns: 15,                     // turns without keyword ‚Üí evict document
  commandPrefix: "/R",              // prefix for manual commands
  logFile: "r-awareness/r-awareness.log",
  storageDir: "r-awareness",
  keywordsFile: "r-awareness/keywords.json",
};

let config = { ...DEFAULT_CONFIG };
let workspaceDir = "";

// ============================================================================
// State
// ============================================================================

// Keyword manifest: keyword (lowercase) ‚Üí { docPath, level, autoGenerated }
let keywordManifest = new Map();

// Currently injected docs: docPath ‚Üí { content, tokens, level, lastKeywordTurn, manuallyLoaded }
let injectedDocs = new Map();

// Keywords queued from AI response for next turn
let queuedKeywords = [];

// Turn counter (incremented on each human message)
let humanTurnCount = 0;

// Pause state
let paused = false;

// Initialization flag
let initialized = false;

// ============================================================================
// Utilities
// ============================================================================
function log(level, msg, data) {
  if (!workspaceDir) return;
  const ts = new Date().toISOString();
  const line = `[${ts}] [${level}] ${msg}${data ? " " + JSON.stringify(data) : ""}`;
  try {
    fs.appendFileSync(path.join(workspaceDir, config.logFile), line + "\n");
  } catch (e) {}
}

function ensureDir(d) {
  if (!fs.existsSync(d)) fs.mkdirSync(d, { recursive: true });
}

function estimateTokens(text) {
  return Math.ceil((text || "").length / 4);
}

// ============================================================================
// Config loading
// ============================================================================
function loadConfig() {
  try {
    const p = path.join(workspaceDir, config.storageDir, "config.json");
    if (fs.existsSync(p)) {
      const userConfig = JSON.parse(fs.readFileSync(p, "utf-8"));
      const cleaned = {};
      for (const [key, val] of Object.entries(userConfig)) {
        if (!key.startsWith("//")) cleaned[key] = val;
      }
      config = { ...DEFAULT_CONFIG, ...cleaned };
    } else {
      ensureDir(path.join(workspaceDir, config.storageDir));
      fs.writeFileSync(p, JSON.stringify(DEFAULT_CONFIG, null, 2));
    }
    log("INFO", "Config loaded", {
      ssotRoot: config.ssotRoot,
      maxDocsPerTurn: config.maxDocsPerTurn,
      tokenBudget: config.tokenBudget,
      ttlTurns: config.ttlTurns,
    });
  } catch (e) {
    log("ERROR", "Config load failed", { error: e.message });
  }
}

// ============================================================================
// Keyword manifest
// ============================================================================

/**
 * Load keyword manifest from JSON file.
 * Format: { "keyword": "path/relative/to/ssotRoot.md", ... }
 * Also auto-generates keywords from document filenames in the SSoT directory.
 */
function loadKeywordManifest() {
  keywordManifest = new Map();

  // 1. Load manual keywords from file
  const kwPath = path.join(workspaceDir, config.keywordsFile);
  if (fs.existsSync(kwPath)) {
    try {
      const data = JSON.parse(fs.readFileSync(kwPath, "utf-8"));
      for (const [keyword, docPath] of Object.entries(data)) {
        const level = detectLevel(docPath);
        keywordManifest.set(keyword.toLowerCase(), {
          docPath,
          level,
          autoGenerated: false,
        });
      }
      log("INFO", "Manual keywords loaded", { count: Object.keys(data).length });
    } catch (e) {
      log("ERROR", "Keywords file parse error", { error: e.message });
    }
  } else {
    // Create empty keywords file
    ensureDir(path.dirname(kwPath));
    fs.writeFileSync(kwPath, JSON.stringify({}, null, 2));
    log("INFO", "Empty keywords file created", { path: kwPath });
  }

  // 2. Auto-generate keywords from SSoT directory structure
  if (config.ssotRoot && fs.existsSync(config.ssotRoot)) {
    autoGenerateKeywords(config.ssotRoot, "");
  }

  log("INFO", "Keyword manifest built", {
    total: keywordManifest.size,
    manual: [...keywordManifest.values()].filter(v => !v.autoGenerated).length,
    auto: [...keywordManifest.values()].filter(v => v.autoGenerated).length,
  });
}

/**
 * Auto-generate keywords from document names in SSoT directory.
 * "R-MEMORY-SPEC.md" ‚Üí keywords: "r-memory-spec", "r-memory", "memory"
 * L0 (vision/mission), L1 (architecture), L2 (projects) get auto-generated keywords.
 * L3 (drafts) and L4 (notes) are manual-only (/R load).
 */
function autoGenerateKeywords(dir, relPath) {
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      const rel = relPath ? path.join(relPath, entry.name) : entry.name;

      if (entry.isDirectory()) {
        // Skip L3 and L4 directories (manual-only levels)
        // L0 (vision/mission), L1 (architecture), L2 (projects) auto-inject via keywords
        if (entry.name.toUpperCase().startsWith("L3") || entry.name.toUpperCase().startsWith("L4")) continue;
        autoGenerateKeywords(fullPath, rel);
      } else if (entry.name.endsWith(".md")) {
        const level = detectLevel(rel);
        if (level >= 3) continue; // Never auto-inject L3 or L4

        const basename = entry.name.replace(/\.md$/i, "");
        const keywords = generateKeywordsFromName(basename);

        for (const kw of keywords) {
          const kwLower = kw.toLowerCase();
          // Don't override manual keywords
          if (!keywordManifest.has(kwLower) || keywordManifest.get(kwLower).autoGenerated) {
            keywordManifest.set(kwLower, {
              docPath: rel,
              level,
              autoGenerated: true,
            });
          }
        }
      }
    }
  } catch (e) {
    log("WARN", "Auto-generate scan error", { dir, error: e.message });
  }
}

/**
 * Generate keyword variants from a document name.
 * "SSOT-L2-R-MEMORY" ‚Üí ["ssot-l2-r-memory", "r-memory", "memory"]
 * "System_Overview" ‚Üí ["system_overview", "system overview", "overview"]
 */
function generateKeywordsFromName(name) {
  const keywords = new Set();

  // Full name (normalized)
  const normalized = name.toLowerCase().replace(/[_]/g, " ").replace(/[-]+/g, "-");
  keywords.add(normalized);
  keywords.add(normalized.replace(/-/g, " "));

  // Strip SSOT-L{N}- prefix if present
  const stripped = normalized.replace(/^ssot[-\s]?l\d[-\s]?/i, "");
  if (stripped !== normalized) {
    keywords.add(stripped);
    keywords.add(stripped.replace(/-/g, " "));
  }

  // Individual significant words (length > 3 to avoid noise)
  const words = stripped.replace(/[-_]/g, " ").split(/\s+/);
  for (const word of words) {
    if (word.length > 3) {
      keywords.add(word);
    }
  }

  return [...keywords];
}

/**
 * Detect SSoT level from relative path.
 * "L1/ARCHITECTURE.md" ‚Üí 1
 * "L2/R-MEMORY.md" ‚Üí 2
 * Falls back to 2 if no level prefix found.
 */
function detectLevel(relPath) {
  const match = relPath.match(/L(\d)/i);
  if (match) return parseInt(match[1]);
  return 2; // default to project level
}

// ============================================================================
// Document loading
// ============================================================================

/**
 * Read a SSoT document from disk and return its content.
 * Returns null if not found or unreadable.
 */
function loadDocument(docPath) {
  const fullPath = path.join(config.ssotRoot, docPath);
  try {
    if (!fs.existsSync(fullPath)) {
      log("WARN", "Document not found", { path: docPath });
      return null;
    }
    const content = fs.readFileSync(fullPath, "utf-8");
    return content;
  } catch (e) {
    log("ERROR", "Cannot read document", { path: docPath, error: e.message });
    return null;
  }
}

// ============================================================================
// Keyword scanning
// ============================================================================

/**
 * Scan text for keywords. Returns array of matched keyword entries.
 * Case-insensitive, word-boundary aware.
 */
function scanForKeywords(text) {
  if (!text || typeof text !== "string") return [];
  const textLower = text.toLowerCase();
  const matches = [];

  for (const [keyword, entry] of keywordManifest) {
    // Word-boundary check: keyword must not be part of a longer word
    // Use simple indexOf + boundary check for performance
    let idx = 0;
    while (idx < textLower.length) {
      const pos = textLower.indexOf(keyword, idx);
      if (pos === -1) break;

      const before = pos > 0 ? textLower[pos - 1] : " ";
      const after = pos + keyword.length < textLower.length ? textLower[pos + keyword.length] : " ";

      // Accept if boundaries are non-alphanumeric
      const boundaryChars = /[^a-z0-9]/;
      if (boundaryChars.test(before) && boundaryChars.test(after)) {
        matches.push({ keyword, ...entry });
        break; // One match per keyword is enough
      }
      idx = pos + 1;
    }
  }

  return matches;
}

// ============================================================================
// Injection logic
// ============================================================================

/**
 * Process keyword matches: load documents, manage TTL, enforce limits.
 * Mutates injectedDocs map as a side effect.
 */
function processMatches(matches, source) {
  if (paused && source !== "command") return "";

  // Refresh TTL for already-injected docs that match
  for (const match of matches) {
    if (injectedDocs.has(match.docPath)) {
      injectedDocs.get(match.docPath).lastKeywordTurn = humanTurnCount;
    }
  }

  // Find new docs to inject (not already in context)
  const newDocs = [];
  for (const match of matches) {
    if (!injectedDocs.has(match.docPath)) {
      newDocs.push(match);
    }
  }

  // Deduplicate by docPath
  const uniqueNew = new Map();
  for (const doc of newDocs) {
    if (!uniqueNew.has(doc.docPath)) {
      uniqueNew.set(doc.docPath, doc);
    }
  }

  // Sort by priority: L1 > L2 > L3
  const sorted = [...uniqueNew.values()].sort((a, b) => a.level - b.level);

  // Load and inject within limits
  let currentTokens = [...injectedDocs.values()].reduce((sum, d) => sum + d.tokens, 0);
  let currentCount = injectedDocs.size;

  for (const doc of sorted) {
    if (currentCount >= config.maxDocsPerTurn) {
      log("WARN", "Max docs limit reached", { limit: config.maxDocsPerTurn });
      break;
    }

    const content = loadDocument(doc.docPath);
    if (!content) continue;

    const tokens = estimateTokens(content);
    if (currentTokens + tokens > config.tokenBudget) {
      log("WARN", "Token budget exceeded, skipping", {
        docPath: doc.docPath,
        tokens,
        budget: config.tokenBudget,
        used: currentTokens,
      });
      continue;
    }

    injectedDocs.set(doc.docPath, {
      content,
      tokens,
      level: doc.level,
      lastKeywordTurn: humanTurnCount,
      manuallyLoaded: false,
    });

    currentTokens += tokens;
    currentCount++;

    log("INFO", "Injected", { docPath: doc.docPath, level: doc.level, tokens });
  }

  // Replace existing docs that match (re-read from disk for fresh content)
  for (const match of matches) {
    if (injectedDocs.has(match.docPath) && !newDocs.some(d => d.docPath === match.docPath)) {
      const freshContent = loadDocument(match.docPath);
      if (freshContent) {
        const existing = injectedDocs.get(match.docPath);
        const oldTokens = existing.tokens;
        const newTokens = estimateTokens(freshContent);
        // Check token budget: would the size increase push us over?
        const otherTokens = [...injectedDocs.values()].reduce((s, d) => s + d.tokens, 0) - oldTokens;
        if (otherTokens + newTokens > config.tokenBudget) {
          log("WARN", "Replacement exceeds token budget, keeping old version", {
            docPath: match.docPath, oldTokens, newTokens, budget: config.tokenBudget,
          });
          existing.lastKeywordTurn = humanTurnCount; // Still refresh TTL
          continue;
        }
        existing.content = freshContent;
        existing.tokens = newTokens;
        existing.lastKeywordTurn = humanTurnCount;
        if (oldTokens !== newTokens) {
          log("INFO", "Replaced (updated)", { docPath: match.docPath, oldTokens, newTokens });
        }
      }
    }
  }

  // TTL eviction: remove docs that haven't been mentioned recently
  for (const [docPath, doc] of injectedDocs) {
    if (doc.manuallyLoaded) continue; // Manual loads don't expire
    const age = humanTurnCount - doc.lastKeywordTurn;
    if (age > config.ttlTurns) {
      log("INFO", "TTL evicted", { docPath, age, ttl: config.ttlTurns });
      injectedDocs.delete(docPath);
    }
  }

  // Build injection content (side effect: processMatches modified injectedDocs)
  // Caller will call buildInjectionContent() separately
}

/**
 * Build the SSoT content block to append to system prompt.
 * Sorted by level (L1 first) then by load order.
 */
function buildInjectionContent() {
  if (injectedDocs.size === 0) return "";

  const docs = [...injectedDocs.entries()]
    .sort((a, b) => a[1].level - b[1].level);

  const parts = [
    "\n\n<!-- R-Awareness: SSoT Context -->",
    "<r-awareness-context>",
  ];

  for (const [docPath, doc] of docs) {
    parts.push(`\n--- ${docPath} (L${doc.level}) ---`);
    parts.push(doc.content);
  }

  parts.push("</r-awareness-context>");
  parts.push("<!-- End R-Awareness -->\n");

  return parts.join("\n");
}

// ============================================================================
// Command processing
// ============================================================================

/**
 * Check if message is a /R command and process it.
 * Returns { isCommand, response } where response is shown to user.
 */
function processCommand(text) {
  if (!text || typeof text !== "string") return { isCommand: false };

  const trimmed = text.trim();
  const prefix = config.commandPrefix;

  if (!trimmed.startsWith(prefix + " ") && trimmed !== prefix) {
    return { isCommand: false };
  }

  const remainder = trimmed.slice(prefix.length).trim();
  if (!remainder) {
    // Bare "/R" with no subcommand ‚Üí show help
    return processCommand(prefix + " help");
  }
  const args = remainder.split(/\s+/);
  const cmd = args[0].toLowerCase();
  const cmdArg = args.slice(1).join(" ");

  switch (cmd) {
    case "load": {
      if (!cmdArg) return { isCommand: true, response: `‚ö†Ô∏è R-Awareness: Usage: ${prefix} load <path>` };
      const content = loadDocument(cmdArg);
      if (!content) return { isCommand: true, response: `‚ö†Ô∏è R-Awareness: Document not found: ${cmdArg}` };
      const tokens = estimateTokens(content);
      injectedDocs.set(cmdArg, {
        content,
        tokens,
        level: detectLevel(cmdArg),
        lastKeywordTurn: humanTurnCount,
        manuallyLoaded: true,
      });
      log("INFO", "Manual load", { docPath: cmdArg, tokens });
      return { isCommand: true, response: `‚úÖ Loaded: ${cmdArg} (~${tokens} tokens)` };
    }

    case "remove": {
      if (!cmdArg) return { isCommand: true, response: `‚ö†Ô∏è R-Awareness: Usage: ${prefix} remove <path>` };
      if (injectedDocs.has(cmdArg)) {
        injectedDocs.delete(cmdArg);
        log("INFO", "Manual remove", { docPath: cmdArg });
        return { isCommand: true, response: `‚úÖ Removed: ${cmdArg}` };
      }
      return { isCommand: true, response: `‚ö†Ô∏è R-Awareness: Not loaded: ${cmdArg}` };
    }

    case "clear": {
      const count = injectedDocs.size;
      injectedDocs.clear();
      log("INFO", "Clear all", { count });
      return { isCommand: true, response: `‚úÖ Cleared ${count} documents` };
    }

    case "list": {
      if (injectedDocs.size === 0) {
        return { isCommand: true, response: "üìã No documents currently loaded." };
      }
      const lines = ["üìã Loaded documents:"];
      for (const [docPath, doc] of injectedDocs) {
        const age = humanTurnCount - doc.lastKeywordTurn;
        const manual = doc.manuallyLoaded ? " [manual]" : "";
        lines.push(`  L${doc.level} ${docPath} (~${doc.tokens}t, age: ${age}/${config.ttlTurns})${manual}`);
      }
      const totalTokens = [...injectedDocs.values()].reduce((s, d) => s + d.tokens, 0);
      lines.push(`  Total: ${injectedDocs.size} docs, ~${totalTokens}/${config.tokenBudget} tokens`);
      return { isCommand: true, response: lines.join("\n") };
    }

    case "pause": {
      paused = true;
      log("INFO", "Paused");
      return { isCommand: true, response: "‚è∏Ô∏è R-Awareness auto-injection paused" };
    }

    case "resume": {
      paused = false;
      log("INFO", "Resumed");
      return { isCommand: true, response: "‚ñ∂Ô∏è R-Awareness auto-injection resumed" };
    }

    case "help": {
      return {
        isCommand: true,
        response: [
          `R-Awareness commands (prefix: ${prefix})`,
          `  ${prefix} load <path>  ‚Äî Force-load a document`,
          `  ${prefix} remove <path> ‚Äî Unload a document`,
          `  ${prefix} clear ‚Äî Remove all injected docs`,
          `  ${prefix} list ‚Äî Show loaded documents`,
          `  ${prefix} pause ‚Äî Disable auto-injection`,
          `  ${prefix} resume ‚Äî Re-enable auto-injection`,
          `  ${prefix} help ‚Äî Show this help`,
        ].join("\n"),
      };
    }

    default:
      return { isCommand: true, response: `‚ö†Ô∏è R-Awareness: Unknown command "${cmd}". Use ${prefix} help` };
  }
}

// ============================================================================
// Extract text from AI response messages
// ============================================================================
function extractAIResponseText(messages) {
  const parts = [];
  if (!Array.isArray(messages)) return "";

  for (const msg of messages) {
    if (msg.role === "assistant" && Array.isArray(msg.content)) {
      for (const block of msg.content) {
        if (block.type === "text" && block.text) {
          parts.push(block.text);
        }
      }
    }
  }
  return parts.join("\n");
}

// ============================================================================
// Extension entry point
// ============================================================================
module.exports = function rAwarenessExtension(api) {
  function init() {
    if (initialized) return;
    initialized = true;
    workspaceDir = process.env.OPENCLAW_WORKSPACE || path.join(process.env.HOME, ".openclaw", "workspace");
    ensureDir(path.join(workspaceDir, config.storageDir));
    loadConfig();

    if (!config.ssotRoot) {
      log("ERROR", "ssotRoot not configured ‚Äî R-Awareness disabled");
      config.enabled = false;
      return;
    }

    if (!fs.existsSync(config.ssotRoot)) {
      log("ERROR", "ssotRoot directory not found", { path: config.ssotRoot });
      config.enabled = false;
      return;
    }

    loadKeywordManifest();

    log("INFO", "R-Awareness V1.0 init", {
      workspace: workspaceDir,
      ssotRoot: config.ssotRoot,
      keywords: keywordManifest.size,
      maxDocs: config.maxDocsPerTurn,
      tokenBudget: config.tokenBudget,
      ttl: config.ttlTurns,
    });
  }

  /**
   * before_agent_start: Scan user prompt for keywords, inject SSoT into system prompt.
   * Also processes /R commands and queued keywords from previous AI response.
   */
  api.on("before_agent_start", async (event, ctx) => {
    try {
      init();
      if (!config.enabled) return;

      const prompt = event.prompt || "";
      const systemPrompt = event.systemPrompt || "";

      humanTurnCount++;

      // 1. Check for /R command
      const cmdResult = processCommand(prompt);
      if (cmdResult.isCommand) {
        log("INFO", "Command processed", { response: cmdResult.response });
        // Return a message for the user and the updated system prompt
        const injection = buildInjectionContent();
        return {
          systemPrompt: injection ? systemPrompt + injection : undefined,
          message: cmdResult.response,
        };
      }

      // 2. AI keyword queue processing DISABLED (feedback loop fix ‚Äî 2026-02-15)
      // queuedKeywords always empty now since agent_end scanning is disabled

      // 3. Cold start: first turn loads only whitelisted docs, no keyword scanning
      if (config.coldStartOnly && humanTurnCount === 1) {
        const coldDocs = config.coldStartDocs || [];
        if (coldDocs.length > 0) {
          log("INFO", "Cold start: loading whitelist only", { docs: coldDocs });
          for (const relPath of coldDocs) {
            const fullPath = path.join(config.ssotRoot, relPath);
            if (fs.existsSync(fullPath)) {
              const content = fs.readFileSync(fullPath, "utf-8");
              const tokens = estimateTokens(content);
              injectedDocs.set(relPath, {
                content, tokens, level: 1,
                lastKeywordTurn: humanTurnCount,
                manuallyLoaded: false,
              });
            } else {
              log("WARN", "Cold start doc not found", { path: fullPath });
            }
          }
        } else {
          log("INFO", "Cold start: no whitelist configured, starting empty");
        }
        // Skip keyword scanning on first turn
        const injection = buildInjectionContent();
        if (injection) {
          const totalTokens = [...injectedDocs.values()].reduce((s, d) => s + d.tokens, 0);
          log("INFO", "Injecting into system prompt (cold start)", { docs: injectedDocs.size, tokens: totalTokens });
          return { systemPrompt: systemPrompt + injection };
        }
        return undefined;
      }

      // 4. Scan human message for keywords (turn 2+)
      const matches = scanForKeywords(prompt);
      if (matches.length > 0) {
        log("INFO", "Human keywords matched", {
          keywords: matches.map(m => m.keyword),
          docs: [...new Set(matches.map(m => m.docPath))],
        });
        processMatches(matches, "human");
      }

      // 4. Build and inject SSoT content
      const injection = buildInjectionContent();
      if (injection) {
        const totalTokens = [...injectedDocs.values()].reduce((s, d) => s + d.tokens, 0);
        log("INFO", "Injecting into system prompt", {
          docs: injectedDocs.size,
          tokens: totalTokens,
        });
        return { systemPrompt: systemPrompt + injection };
      }

      // No injection needed ‚Äî return undefined to keep system prompt unchanged
      return undefined;

    } catch (e) {
      log("ERROR", "before_agent_start error", { error: e.message, stack: e.stack });
      return undefined; // Don't break the agent on error
    }
  });

  /**
   * agent_end: AI keyword scanning DISABLED.
   * Reason: AI responses contain injected SSoT content, creating a feedback loop
   * where injected docs trigger re-injection of the same docs every turn.
   * Only human keywords are used for now. ‚Äî 2026-02-15
   */
  // AI keyword scanning disabled - human keywords only
};
